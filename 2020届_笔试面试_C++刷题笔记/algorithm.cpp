/********************************************************************************************************
Description:本例程提供了 C++的 STL 常用数据结构及其算法的使用范例，为面试笔试编程题提供便利
*********************************************************************************************************/


/*************************************************顺序容器***********************************************
/*-------------------------------------------选择顺序容器的准则： -------------------------------------------
1）若要求支持随机访问,vector queue
2）程序要求在中间插入或者删除元素，则选择使用 list 或者 forward_list
3）如果程序只会在头部或者尾部插入删除数据，则选择使用 queue
4）如果不知道选择哪种容器，则在程序中只使用 list 和 vector 容器，并且只使用迭代器而不使用下标操作
-----------------------------------------------------------------------------------------------------------*/
#include <vector>		//可变大小数组，支持快速随机访问，在尾部之外的其它位置插入或者删除元素可能很慢
#include <string>		//和 vector 是一样的，支持快速随机访问，在尾部之外的其他的位置插入都很慢
#include <list>			//双向链表，只支持双向顺序访问，在 list 中的任意位置插入和删除都很快
#include <forward_list> //单向链表，只支持单向顺序访问，在链表任意位置插入和删除都很快,是 c++11 新加的标准//forward_list 单向链表设计目标是达到与手写单向链表相当的性能。
#include <queue>		//先进先出，单端队列，在 queue 的中间位置插入或者删除元素代价都很高
#include <deque>		//双端队列，支持快速随机访问（肯定是顺序存储式队列），从头尾位置处插入和删除速度很快，与内置数组相比，更加安全和方便；
#include <array>		//固定数组大小，支持快速，不能添加或者删除元素，是 c++11 新加的标准，支持对象赋值或者拷贝操作
#include <stack>		//栈结构，支持栈顶的快速进栈出栈操作，在栈的其他部位不可操作。
/*************************************************顺序容器***********************************************/


/*************************************************关联容器***********************************************/
#include <map>			//存储键值对，自动根据键值排序
#include <set>			//只存储键值，自动根据键值排序
/*************************************************关联容器***********************************************/


/*************************************************无序容器***********************************************/
/*************************************************无序容器***********************************************/


/*----------------------------------------容器所共同支持的操作--------------------------------------------
1）类型别名
	1. iterator、、const_iterator、、size_type、、difference_type、、reference、、const_reference

2）构造函数
	1. C c; //调用默认构造函数，无参
	2. C c1(c2); //调用复制构造函数，有参，可合成
	3. C c(b, e); //调用构造函数，带参，迭代器 b,e 指向的容器范围进行初始化构造
	4. C c{a, b, c, ......}; //列表初始化构造，带参构造

3）赋值与 swap
	c1 = c2
	c1 = {a, b, c, ......}
	c1.swap(c2) //成员函数版的交换函数 // 交换两个容器（同类型）内的元素
	swap(c1, c2) //非成员函数版的交换函数 // 交换两个容器（同类型）内的元素

4）大小
	1. c.size() //求容器中元素的个数，
	2. c.max_size() //容器最多可保存的元素个数
	3. c.empty() //返回容器是否为空

5）插入、删除元素
	1. c.insert(args) //插入元素
	2. c.emplace(inits) //使用 inits 构造 c 中的一个元素
	3. c.erase(args) //删除元素

6）获取迭代器
	1. c.bengin() c.end()
	2. c.cbegin(), c.cend()

7）反向迭代器的成员
	1. reverse_iterator
	2. const_reverse_interator
	3. c.rbegin(), c.rend()
	4. c.crbegin(), c.crend()
-----------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------容器的定义及初始化--------------------------------------------
C c;				 默认构造函数，若 c 是个 array，则执行默认初始化，若是 vector 等则是空容器
C c1(c2)			 c1 初始化为 c2 的拷贝，必须是同种类型，且保存的相同的元素类型，若是 array，两者还必须是相同的大小
C c1 = c2			 同上
C c{a, b, c,...}	 列表初始化构造，带参构造
C c = {a, b, c,...}  同上
C c(b, e)			 c 初始化为迭代器 [b,e) 指定范围中元素的拷贝
//只有顺序容器才支持的操作：
C c(n)				 c 包含 n 个元素,这些元素进行了值初始化(默认初始化为0)
C c(n, t)			 c 包含 n 个初始化为值 t 的元素
//关于 array 类型：
array<int, 40>		 必须定义大小，array固定大小
-----------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------swap()--------------------------------------------
swap(c1, c2)		 交换两个容器的元素
c1.wap(c2)			 同上
//assign 操作：不适合关联容器和 array
seq.assign(b, e)	 使用迭代器 [b， e) 替换容器中的元素
seq.assign(il)		 使用列表进行复制
seq.assign(n, t)	 使用 n 个值为 t 的元素。
//使用 swap() 交换两个容器的值，不对元素进行拷贝工作，所以速度很快，除 array 以外，统一使用非成员 swap(）是一个很好的选择
vector<string> svec1(10);
vector<string> svec2(20);
swap(svec1, svec2);
-----------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------容器大小操作-----------------------------------------------
>   <   ==				比和 string 字符串的比较一样的，只有容器的元素定义了关系运算符，才可以比较容器之间的大小
size()					返回容器中元素的个数
empty()					容器是否为空
max_size()				该类型容器最大容纳的元素的个数
//forward_list 不支持 size()操作，原因肯定是因为要和手写单向链表一致
-----------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------顺序容器操作-----------------------------------------------
//forward_list			有自己专门的 insert 和 emplace,不支持 push_back 和 emplace_back, 
//vector、string		不支持 push_front、以及 emplace_front,虽然有些容器支持,但是对于 insert(begin,...)没有限制
c.push_back(t)			在 c 的尾部创建 t 或者 args 创建的元素，返回 void
c.emplace_back(args)
c.push_front(t)			在 c 的开头创建 t 或者 args 创建的元素，返回 void
c.emplace_front(t)
c.insert(p, n, t)		在迭代器 p 之前插入 n 个值为 t 的元素，返回新添加的第一个元素的迭代器，若 n 为 0，则返回 p
c.insert(p, b, e)		将迭代器 b, e 指向的元素之前插入到 p 所指向新添加元素之前，返回新添加第一个元素的迭代器
//insert 是按顺序向后插入的，比如{0, 1, 2}的 begin 插入{3， 4， 5}是{3, 4, 5, 0, 1, 2}

//向一个 vector/string/deque 中插入元素会使所有指向容器的迭代器、引用、指针失效。
//当我们使用一个对象来初始化容器时，或者将元素插入容器中，实际上放入容器的是其对象值的一个拷贝，两者并无关联
//vector 和 string 不支持 push_front()操作，而 list、 forward_list、 deque 支持 push_front()操作;push_front 是一种倒序的结果
//emplace_back   emplace   emplace_front 是在内存空间里直接构造对象，而不是拷贝。 emplace_back(args)
*************************************************************************************************************
访问元素，除了 forward_list，每一个容器都提供了 c.front(),以及 c.back()成员，用以返回容器的首尾元素的引用。
at 和下标[]操作只适合 string、vector、deque、array，如果越界，则编译器会报出 out_of_range 错误
*************************************************************************************************************
以下操作不适合 array，因为这些操作会改变容器的大小，不适于 array
c.pop_back()		//删除 c 中的尾元素,若 c 为空则函数行为未定义
c.pop_front()		//删除队头元素，若 c 为空，则函数未定义
c.erase(p)			//删除迭代器所指的元素，返回一个指向被删除元素之后的元素的迭代器，若 p 指向最后一个元素，则返回尾后迭代器，
c.erase(p, e)		//删除迭代器 b 和 e 所指定范围内的元素，返回一个指向最后一个被删除元素之后的元素的迭代器，若 e 本身也是最后一个元素，那么也返回尾后迭代器,
c.clear()			//删除所有的元素，
c.resize()			//调整 c 的大小为 c 个元素，若不足，则补足
//PS：删除 deque 除首尾之外的所有元素都会值得所有迭代器，引用或者指针失效，指向 vector 以及 string 的删除点之后位置的
迭代器、引用、指针失效。
**************************************************************************************************************
forward_list 特有的操作： forward_list<int >lst
lst.before_begin()
lst.cbefore_begin()				返回首前迭代器
lst.insert_after(p, t)			在迭代器 p 之后插入为值 t 的对象
lst.insert_after(p, n, t)		n 个值为 t 的对象 返回最后一个插入的元素的迭代器，
lst.insert_after(p, b, e)		n 个值为 t 的对象 返回最后一个插入的元素的迭代器，
lst.insert_after(p, il)			n 个值为 t 的对象 返回最后一个插入的元素的迭代器，
emplace_after(p, args)			在 p 之后创建元素
lst.erase_after(p)				删除 p 之后的元素,返回一个被删除元素之后的元素的迭代器
lst.erase_after(b, e)			删除[p, e)的元素,返回最后一个被删除元素之后的元素的迭代器
***********************************************************************************************************
c.capacity()					返回在不扩张内存的情况下可以容纳多少元素。
c.reserve()						分配至少能容纳 n 个元素的内存空间
c.size()						容器中有多少元素
-----------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------额外的 string 构造方法--------------------------------------------
string s(cp, n)							s 是 cp 指向的数组中的前 n 个字符的拷贝，此数组至少应该包含 n 个字符
string s(s2, pos2)						s 是 s2 从下标 pos2 开始的拷贝，
string s(s2, pos2, len2)				s 是 s2 从下标 pos2 开始，长度为 len2 的拷贝
s.substr(pos = 0, n = s.size() - pos)	返回一个 string 包含从 pos 开始的 n 个字符的拷贝，返回子串
string s("hello world");
string s2 = s.substr(0, 5);				//s2 = hello
string s3 = s.substr(6);				//s3 = world    n不写，默认到s的末尾
string s4 = s.substr(6, 11);			//s4 = world
string s5 = s.substr(12);				//抛出一个 out_of_range

//除了普通的 insert()和 erase()操作， string 还有以下的重载版本，都是在 pos 之前插入或者删除，字符串下标是从 0 开始的
//string 还提供了两个额外的成员 append(),replace()， append()是在 string 末尾加入的一种形式，而 replace 是调用 erase()和insert()的简写形式
s.insert(pos, args)						//在 pos 之前插入 args 指定的字符， pos 是个下标或者是一个迭代器，
										//接受下标的版本返回一个指向 s 的引用,接受迭代器的版本返回指向第一个插入字符的迭代器
s.erase(pos, len)						//删除从 pos 处开始的 len 个字符，如果 len 省略则删除 pos 开始的所有字符，返回一个指向 s 的引用
s.replace(range, args)					//删除 range 内的元素，替换为 args 的元素， args 可以是一个下标加一个长度，或者一对迭代器，返回返回一个指向 s 的引用
s.append(args)							//将 args 加入到 s 的尾部，返回一个指向 s 的引用
s.assign(args)							//将 s 中的字符替换为 args 字符，返回一个引用
***************************************************************************************************************
string 的搜索函数：
	(1) s.find(args)						//查找 s 中第一次出现args的位置,并返回子串在主串中第一个字符的下标
	(2) s.rfind(args)						//查找最后一个...
	(3) s.find_first_of(args)				//在 s 中查找 args 中任何一个字符的第一次出现的位置，
	(4) s.find_last_of(args)				//在 s 中查找 args 中任何一个字符最后一次出现的位置。
	(5) s.find_first_not_of(args)			//在 s 中查找第一个不在 args 中的字符
	(6) s.find_last_not_of(args)			//查找最后一个不在 args 中的字符
	(1) args 必须是以下的形式：
		（ c, pos）								从 s 中位置 pos 开始查找字符 c， pos 默认 0。
		（ s2, pos）							从 s 中位置 pos 开始查找字符串 s2， pos 默认 0。
		（ cp, pos）							从 s 中位置 pos 开始查找 cp 指向的以空字符结尾的 C 风格字符串， pos 默认为 0
		（ cp, pos, n）							从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符。 pos 和 n 无默认值
**************************************************************************************************************
compare 函数：这与 C 标准库，提供的 strcmp 很相似；返回值：相等（0），前者大于后者（1），前者小于后者（-1）
	（ 1） s.compare(s2)					//比较 s 和 s2
	（ 2） s.compare(pos1, n1, s2)			//将 pos1 开始的长度为 n1 的字符串和 s2 进行比较
	（ 3） s.compare(pos1, n1, s2, pos2, n2)
	（ 4) s.compare(cp)						//比较 s 与 cp 指向的以空格结尾的字符数组
-----------------------------------------------------------------------------------------------------------*/


/*------------------------------------------------容器适配器-------------------------------------------------
//除了 string   vector   list   forword_list   deque   array 等顺序容器之外，还定义了 queue   stack   priority_queue 等适配器
（ 1） stack //栈，先入后出结构，常用操作：
	（ 1） pop()
	（ 2） top()
	（ 3） push()
	（ 4） empty()
（ 2） queue //队列，不是双端队列，但是，是基于 deque 实现的， priority_queue 是基于 vector 实现的，常用操作：
	（ 1） q.pop()
	（ 2） q.top()
	（ 3） q.front()
	（ 4） q.back()
	（ 5） q.empty()
-----------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------关联容器--------------------------------------------------
//关联容器支持高效的关键字查找和访问，主要有 map 和 set 两种。再冠以 multi 以及 unorder 就一共有八种关联容器：
	map
	set
	multimap
	multiset
	unordered_map
	unordered_set
	unordered_multimap
	unordered_multiset
关联容器：有三个比较关键的类型 key_value   mapped_type   value_type //
有两个数据成员 first、 second 两个， first 是关键字， second 是值，进行下标运算的时候，若元素不在容器内，那么容器创建新键值对，并且值为 0；需要手动加加；
而 set 的 find()函数，找到了返回该元素迭代器，找不到返回尾后迭代器；
//关联容器的关键值一定要有  比较运算符  ，因为插入容器的元素默认是按字典序排序的；
//关联容器迭代器： map 的关键值是 const 类型，而 set 的迭代器就是 const 类型，且迭代器支持++操作
//迭代器只支持 ++、-- 运算，不支持 +n、-n 运算
**********************************************************************************************************
pair 类型:
	(1)pair<t1, t2> p()
	(2)pair<t1, t2> p = {v1, v2};
	(3)make_pair(v1, v2)
**********************************************************************************************************
(1)插入操作：map、set、unordered_map、unordered_set
	c.insert(v) 对于 map、set 当 v 不在容器中才执行插入操作（插入里面的关键字不能重复）
	c.insert(b, e)
	c.insert(il)
//插入单个元素，返回一个 pair 类型， pair 的 second 成员是一个 bool 值，返回是否插入成功则返回 true， first 无论何时都指向 value，例如：
std::map<std::string, int> word_count;
std::string tmp;
while (std::cin >> tmp)
{
	auto ret = word_count.insert({ tmp, 1 });
	if (!ret.second)
	//++word_count[tmp];
	++ret.first->second;
}
auto begin = word_count.begin();
while (begin != word_count.end())
{
	std::cout << begin->first << ":" << begin->second << std::endl;
	++begin;
}
(2)而向 multimap 以及 multiset 中插入元素，返回一个指向新值的迭代器，没有 second，因为总会新插入一个迭代器（插入里面的关键字可以重复）
(3)map 的下标操作：
（ 1） c[k] //下标操作会返回一个 mapped_type 而解引用操作会返回一个 value_type
（ 2） c.at(k)
(4)find()操作
例： if(word_count.find("foobar") == word_count.end())
但是如果是一个 multimap 或者 multiset 的时候，由于具有相同关键字的连续存储，则需要先使用 count 获取数量，在使用
find()函数获取第一个元素，然后在使用循环挨个访问；
可以使用面向迭代器的解决方法：
lower_bound() upper_bound()来解决，前者指向第一个匹配的关键字，后者最后匹配的关键字，也可以只用 equal_range 来实现
若存在返回一个 pair， first 指向第一个， second 指向最后一个。若不存在，则都返回指向可以插入的位置
----------------------------------------------关联容器--------------------------------------------------*/